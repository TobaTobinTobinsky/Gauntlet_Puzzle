üìò DOCUMENTO DE ARQUITECTURA T√âCNICA (D√çA 2)
Objetivo: Implementar un sistema de interacci√≥n b√°sico donde el jugador pueda visualizar un puntero en pantalla y rotar objetos del entorno (estatuas) 45 grados al pulsar una tecla.
üìò 1. SISTEMA DE VISUALIZACI√ìN (HUD)
Para otorgar feedback visual de hacia d√≥nde estamos mirando.
1.1 Creaci√≥n del Widget (WBP_Crosshair)
En la carpeta _Game/UI, creamos un nuevo Widget Blueprint llamado WBP_Crosshair.
Dentro del editor, a√±adimos un componente Image al Canvas Panel.
Configuramos sus propiedades para centrarlo perfectamente:
Anchors: Center (El recuadro central).
Alignment: (0.5, 0.5).
Position: (0.0, 0.0).
Size: (4.0, 4.0) p√≠xeles.
Color: Blanco con Alpha 0.5 (semitransparente).
1.2 Implementaci√≥n en el Personaje (BP_PuzzleHero)
Abrimos el Blueprint del personaje principal.
En el evento BeginPlay, a√±adimos la l√≥gica para mostrar la interfaz:
Nodo Create Widget (Clase: WBP_Crosshair).
Nodo Add to Viewport (ZOrder: 0).
Al compilar y jugar, verificamos que aparece un punto blanco en el centro de la pantalla.
üìò 2. CONFIGURACI√ìN DEL SISTEMA DE ENTRADA (INPUT ACTION)
Dise√±amos un esquema de control propio para garantizar que la interacci√≥n sea fluida y no existan conflictos de jerarqu√≠a entre el personaje y los objetos del escenario.
2.1 Creaci√≥n del Input Action (IA_Interact)
Para que la tecla "E" pueda ser detectada por m√∫ltiples Blueprints a la vez (tanto por el personaje como por los cubos), configuramos el asset de la siguiente manera:
En la carpeta _Game/Input/Actions, creamos el Input Action IA_Interact.
Configuraci√≥n de Consumo (Vital): En el panel de detalles, dentro de la secci√≥n Consumo de entrada, DESMARCAMOS la casilla "Consume Lower Priority Enhanced Input Mappings".
Raz√≥n T√©cnica: Al desactivar esta opci√≥n, permitimos que la se√±al de la tecla "E" no se detenga en el primer objeto que la escuche, logrando que llegue hasta la l√≥gica interna del cubo interactuable.
2.2 L√≥gica de Interacci√≥n Simplificada (Overlap Event)
Optimizamos el sistema eliminando c√°lculos de traza (Raycast) innecesarios en favor de eventos de colisi√≥n directa.
En el Actor Interactuable (BP_DummyInteract):
Usamos el componente Sphere Collision existente (el mismo que activa la UI).
Habilitar Input (Enable Input):
En el evento OnComponentBeginOverlap (cuando el jugador entra), obtenemos el Player Controller (Get Player Controller 0).
Llamamos al nodo Enable Input conectando el Player Controller.
Resultado: Ahora este actor espec√≠fico puede escuchar las teclas del teclado.
Deshabilitar Input (Disable Input):
En el evento OnComponentEndOverlap (cuando sale), llamamos a Disable Input.
Resultado: Dejamos de escuchar teclas para evitar activaciones accidentales a distancia.
Ejecuci√≥n (Event E):
Simplemente llamamos al Evento de Tecla E (o nuestro Input Action IA_Interact) dentro del Blueprint de la estatua.
Conectamos esto directo a la l√≥gica de rotaci√≥n (Timeline).
üìò 3. IMPLEMENTACI√ìN DE LA ROTACI√ìN DE 45¬∞
Objetivo: Lograr que el objeto gire exactamente 45 grados de forma suave en cada pulsaci√≥n, garantizando que la animaci√≥n se reinicie correctamente siempre.
3.1 Configuraci√≥n de Recepci√≥n de Input
Para que el objeto reconozca la tecla "E" directamente, realizamos el ajuste de jerarqu√≠a:
En los Class Defaults de BP_DummyInteract, localizamos la secci√≥n Input.
Cambiamos Auto Receive Input a Player 0. Esto permite que el cubo escuche al jugador sin nodos extra.
3.2 L√≥gica de Captura (Event Graph)
El Disparador: Colocamos el evento IA_Interact.
Registro de Inicio: Del pin Started, conectamos el nodo Set RotacionInicial (obteniendo el valor de GetActorRotation).
C√°lculo de Destino: Conectamos a Set RotacionObjetivo. Usamos un nodo Combine Rotators:
Pin A: RotacionInicial.
Pin B (Z/Yaw): Escribimos 45.0.
3.3 Configuraci√≥n del Timeline (Giro_45)
A√±adimos el nodo Add Timeline Giro_45.
Dentro del Timeline:
Length (Duraci√≥n): 2.0 segundos.
Track: Creamos un "Float Track" llamado Progreso.
Curva: Ponemos un punto en (0.0, 0.0) y otro en (2.0, 1.0).
Seleccionamos ambos puntos y aplicamos Auto para suavizar el movimiento.
3.4 Ejecuci√≥n y Reinicio de Animaci√≥n (EL FIX)
Para asegurar que la animaci√≥n funcione en cada pulsaci√≥n, conectamos los nodos de la siguiente manera:
Activaci√≥n Cr√≠tica: Conectamos la salida de nuestros "Set" de variables al pin PLAY FROM START del Timeline.
Raz√≥n: Esto reinicia el cron√≥metro de la animaci√≥n a cero en cada interacci√≥n, evitando que el objeto se "teletransporte" en el segundo giro.
Actualizaci√≥n: Del pin Update, llamamos a SetActorRotation.
Mezcla de Datos: En el pin de rotaci√≥n usamos un Lerp (Rotator):
A: RotacionInicial.
B: RotacionObjetivo.
Alpha: El pin Progreso del Timeline.
Shortest Path: Marcamos la casilla. Esto es vital para que el motor no intente dar la vuelta larga (315¬∞) al cruzar el l√≠mite de los 360 grados.
‚úÖ VERIFICACI√ìN FINAL
Colocamos una instancia de BP_DummyInteract en el nivel.
Al presionar Play, nos acercamos, apuntamos con el puntero central y presionamos E.
El objeto rota 45 grados a la derecha de forma suave y se detiene en la posici√≥n correcta.

